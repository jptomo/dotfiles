" vim:se fdm=marker foldlevel=-1:


" ### neobundle.vim ### {{{
filetype plugin indent off

" golang
se rtp+=$GOROOT/misc/vim
se nocompatible

if has('vim_starting')
  se runtimepath+=~/.vim/bundle/neobundle.vim/
endif

call neobundle#rc(expand('~/.vim/bundle/'))

" Let NeoBundle manage NeoBundle
NeoBundleFetch 'Shougo/neobundle.vim'
NeoBundle 'Shougo/vimproc', {'build': {
\           'windows' : 'echo "Sorry, cannot update vimproc binary file in Windows."',
\           'cygwin' : 'make -f make_cygwin.mak',
\           'mac' : 'make -f make_mac.mak',
\           'unix' : 'make -f make_unix.mak'}}

" my bundle
NeoBundle 'The-NERD-tree'
NeoBundle 'The-NERD-Commenter'
NeoBundle 'jonathanfilip/vim-lucius'
NeoBundle 'nathanaelkane/vim-indent-guides'
NeoBundleLazy 'nvie/vim-flake8', {'autoload': {'filetypes': ['python']}}
NeoBundleLazy 'JavaScript-syntax', {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'pangloss/vim-javascript', {'autoload': {'filetypes': ['javascript']}}
NeoBundleLazy 'kchmck/vim-coffee-script', {'autoload': {'filetypes': ['coffee']}}
NeoBundleLazy 'oscarh/vimerl', {'autoload': {'filetypes': ['erlang']}}

filetype plugin indent on
syntax enable

" }}}


" ### encodings ### {{{
if &encoding !=# 'utf-8'
  se encoding=japan
  se fileencoding=japan
endif
if has('iconv')
  let s:enc_euc = 'euc-jp'
  let s:enc_jis = 'iso-2022-jp'
  " iconvがeucJP-msに対応しているかをチェック
  if iconv("\x87\x64\x87\x6a", 'cp932', 'eucjp-ms') ==# "\xad\xc5\xad\xcb"
    let s:enc_euc = 'eucjp-ms'
    let s:enc_jis = 'iso-2022-jp-3'
  " iconvがJISX0213に対応しているかをチェック
  elseif iconv("\x87\x64\x87\x6a", 'cp932', 'euc-jisx0213') ==# "\xad\xc5\xad\xcb"
    let s:enc_euc = 'euc-jisx0213'
    let s:enc_jis = 'iso-2022-jp-3'
  endif
  " fileencodingsを構築
  if &encoding ==# 'utf-8'
    let s:fileencodings_default = &fileencodings
    let &fileencodings = s:enc_jis .','. s:enc_euc .',cp932'
    let &fileencodings = &fileencodings .','. s:fileencodings_default
    unlet s:fileencodings_default
  else
    let &fileencodings = &fileencodings .','. s:enc_jis
    se fileencodings+=utf-8,ucs-2le,ucs-2
    if &encoding =~# '^\(euc-jp\|euc-jisx0213\|eucjp-ms\)$'
      se fileencodings+=cp932
      se fileencodings-=euc-jp
      se fileencodings-=euc-jisx0213
      se fileencodings-=eucjp-ms
      let &encoding = s:enc_euc
      let &fileencoding = s:enc_euc
    else
      let &fileencodings = &fileencodings .','. s:enc_euc
    endif
  endif
  let &fileencodings = 'utf-8,' . &fileencodings
  " 定数を処分
  unlet s:enc_euc
  unlet s:enc_jis
endif
" 日本語を含まない場合は fileencoding に encoding を使うようにする
if has('autocmd')
  function! AU_ReCheck_FENC()
    if &fileencoding =~# 'iso-2022-jp' && search("[^\x01-\x7e]", 'n') == 0
      let &fileencoding=&encoding
    endif
  endfunction
  autocmd BufReadPost * call AU_ReCheck_FENC()
endif
" 改行コードの自動認識
se fileformats=unix,dos,mac
" □とか○の文字があってもカーソル位置がずれないようにする
if exists('&ambiwidth')
  se ambiwidth=double
endif

" バイナリ編集(xxd)モード（vim -b での起動、もしくは *.bin ファイルを開くと発動します）
augroup BinaryXXD
  autocmd!
  autocmd BufReadPre  *.bin let &binary =1
  autocmd BufReadPost * if &binary | silent %!xxd -g 1
  autocmd BufReadPost * se ft=xxd | endif
  autocmd BufWritePre * if &binary | %!xxd -r | endif
  autocmd BufWritePost * if &binary | silent %!xxd -g 1
  autocmd BufWritePost * se nomod | endif
augroup END

"カーソル下の文字コード
"http://vimwiki.net/?tips%2F98
function! Getb()
  let c = matchstr(getline('.'), '.', col('.') - 1)
  let c = iconv(c, &enc, &fenc)
  return String2Dec(c)
endfunction
function! GetB()
  let c = matchstr(getline('.'), '.', col('.') - 1)
  let c = iconv(c, &enc, &fenc)
  return String2Hex(c)
endfunction
" :help eval-examples
" The function Nr2Hex() returns the Hex string of a number.
func! Nr2Hex(nr)
  let n = a:nr
  let r = ""
  while n
    let r = '0123456789ABCDEF'[n % 16] . r
    let n = n / 16
  endwhile
  return r
endfunc
" The function String2Hex() converts each character in a string to a two
" character Hex string.
func! String2Hex(str)
  let out = ''
  let ix = 0
  while ix < strlen(a:str)
    let out = out . Nr2Hex(char2nr(a:str[ix]))
    let ix = ix + 1
  endwhile
  return out
endfunc
func! String2Dec(str)
  let out = ''
  let ix = 0
  while ix < strlen(a:str)
    if ix == 1
      let out = out . ','
    endif
    let out = out . printf('%3d', char2nr(a:str[ix]))
    let ix = ix + 1
  endwhile
  return out
endfunc

" some filetype configuration functions
" 各種関数はファイルを開く際毎度呼ばれる見たいなので setl で設定する
function SettingForPython()
  setl smartindent cinwords=if,elif,else,for,while,try,except,finally,def,class
  autocmd BufWritePre * :%s/\s\+$//ge
endfunction
function SettingForRuby()
  setl tabstop=2 shiftwidth=2 softtabstop=2
  autocmd BufWritePre * :%s/\s\+$//ge
endfunction
function SettingForHTML()
  setl tabstop=2 shiftwidth=2 softtabstop=2
endfunction
function SettingForRST()
  setl tabstop=3 expandtab shiftwidth=3 softtabstop=3
endfunction

" }}}


" ### filetype settings ### {{{

" register filetype
au BufRead,BufNewFile *.coffee se filetype=coffee

" some filetype settings
au QuickfixCmdPost make copen

au FileType python call SettingForPython()
au FileType php call SettingForPython()
au FileType twig call SettingForPython()
au FileType ruby call SettingForRuby()
au FileType sh call SettingForPython()
au FileType ini call SettingForPython()
au FileType cfg call SettingForPython()
au FileType html call SettingForHTML()
au FileType htmldjango call SettingForHTML()
au FileType xml call SettingForHTML()
au FileType xspf call SettingForHTML()
au FileType javascript call SettingForHTML()
au FileType javascript :compiler gjslint
au FileType css call SettingForHTML()
au FileType rst call SettingForRST()
au FileType coffee call SettingForHTML()

au FileType * se formatoptions-=ro

" }}}


" ### settings ### {{{

" 文字色／背景色
se background=light
if has('win32')
    colo blue
elseif filereadable(expand("~/.vim.no-lusius"))
    " lucius で白文字に成ってしまう対応
    colo default
else
    colo lucius
endif

" ウィンドウ表示関係
se number       " 行番号表示
se title        " ウィンドウのタイトルを書き換える
se cursorline   " カーソル行を強調表示

" タブ関連
" Anywhere SID.
function! s:SID_PREFIX()
  return matchstr(expand('<sfile>'), '<SNR>\d\+_\zeSID_PREFIX$')
endfunction

" Set tabline.
function! s:my_tabline()  "{{{
  let s = ''
  for i in range(1, tabpagenr('$'))
    let bufnrs = tabpagebuflist(i)
    let bufnr = bufnrs[tabpagewinnr(i) - 1]  " first window, first appears
    let no = i  " display 0-origin tabpagenr.
    let mod = getbufvar(bufnr, '&modified') ? '!' : ' '
    let title = fnamemodify(bufname(bufnr), ':t')
    let title = '[' . title . ']'
    let s .= '%'.i.'T'
    let s .= '%#' . (i == tabpagenr() ? 'TabLineSel' : 'TabLine') . '#'
    let s .= no . ':' . title
    let s .= mod
    let s .= '%#TabLineFill# '
  endfor
  let s .= '%#TabLineFill#%T%=%#TabLine#'
  return s
endfunction "}}}
let &tabline = '%!'. s:SID_PREFIX() . 'my_tabline()'
set showtabline=2 " 常にタブラインを表示

" The prefix key.
nn [Tag] <Nop>
nm t [Tag]
" Tab jump
" t1 で1番左のタブ、t2 で1番左から2番目のタブにジャンプ
for n in range(1, 9)
  execute 'nnoremap <silent> [Tag]'.n  ':<C-u>tabnext'.n.'<CR>'
endfor

map <silent> [Tag]c :tablast <bar> tabnew<CR>
" tc 新しいタブを一番右に作る
map <silent> [Tag]x :tabclose<CR>
" tx タブを閉じる
map <silent> [Tag]n :tabnext<CR>
" tn 次のタブ
map <silent> [Tag]p :tabprevious<CR>
" tp 前のタブ

" ステータスライン関係
se laststatus=2 " ステータスラインを常に表示
"se statusline=%y=[%{&fileencoding}][\%{&fileformat}]\ %F%m%r%=<%c:%l>
" ファイルパス [filetype][fenc][ff]    桁(ASCII=10進数,HEX=16進数) 行/全体(位置)[修正フラグ]
se statusline=%<%F\ %r%h%w%y%{'['.(&fenc!=''?&fenc:&enc).']['.&ff.']'}%=%4v(ASCII=%{Getb()},HEX=%{GetB()})\ %l/%L(%P)%m

" 特殊記号表示
se list
se lcs=tab\:>-,extends\:<,trail\:-,eol\:$

" SWP BAK ファイル
se noswapfile   " SWF ファイルなし
se nobackup     " BAK ファイルなし
se undodir=expand("~/.local/var/vim/undo")
"se backupdir=$VIM\_vim\backups
"se directory=$VIM\_vim\swaps

" indent
se tabstop=4 shiftwidth=4 softtabstop=4
se smarttab
se expandtab
se autoindent
se smartindent
se cindent
se formatoptions=q
se textwidth=80
se enc=utf-8

" Folding
se foldmethod=indent  " indent でfold
se foldlevel=99       " hoge

" fold keymappings
nn <space> za
vn <space> zf

" 検索関係
se incsearch    " インクリメンタルサーチ
se nowrapscan   " ラップしない
se ignorecase   " 大文字小文字無視
se smartcase    " 大文字で始めたら大文字小文字を区別する
se hlsearch     " 検索文字をハイライト表示

" Nerdtree
nmap <silent> <C-O> :NERDTreeToggle<CR>
let g:NERDTreeShowHidden = 0
let g:NERDTreeIgnore=[
\   '\.svn',
\   '\.pyc',
\   '\.hg',
\   '\.git',
\   '__pycache__',
\   '.egg-info',
\]

" ### flake8 ###
let g:flake8_ignore='E501,E241'

" ### neocomplete ###
let g:neocomplcache_enable_at_startup = 1

" }}}
